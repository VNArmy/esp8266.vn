# ESP8266 Arduino - SPI 

Thư viện SPI hổ trợ hoàn toàn Arduino SPI, API gồm trao đổi dữ liệu, thiết lập phase (CPHA). Việc thiết lập `Clock polarity` (CPOL ) không được hổ trợ đồng thời `SPI_MODE2` và `SPI_MODE3` không làm việc.

# Arduino - SPI

This library allows you to communicate with SPI devices, with the Arduino as the master device.

### A Brief Introduction to the Serial Peripheral Interface (SPI)

Serial Peripheral Interface (SPI) is a synchronous serial data protocol used by microcontrollers for communicating with one or more peripheral devices quickly over short distances. It can also be used for communication between two microcontrollers.

With an SPI connection there is always one master device (usually a microcontroller) which controls the peripheral devices. Typically there are three lines common to all the devices:

- **MISO** (Master In Slave Out) - The Slave line for sending data to the master,
- **MOSI** (Master Out Slave In) - The Master line for sending data to the peripherals,
- **SCK** (Serial Clock) - The clock pulses which synchronize data transmission generated by the master

and one line specific for every device:

- **SS** (Slave Select) - the pin on each device that the master can use to enable and disable specific devices.

When a device's Slave Select pin is low, it communicates with the master. When it's high, it ignores the master. This allows you to have multiple SPI devices sharing the same MISO, MOSI, and CLK lines.

To write code for a new SPI device you need to note a few things:

- What is the maximum SPI speed your device can use? This is controlled by the first parameter in SPISettings. If you are using a chip rated at 15 MHz, use 15000000. Arduino will automatically use the best speed that is equal to or less than the number you use with SPISettings.
- Is data shifted in Most Significant Bit (MSB) or Least Significant Bit (LSB) first? This is controlled by second SPISettings parameter, either MSBFIRST or LSBFIRST. Most SPI chips use MSB first data order.
- Is the data clock idle when high or low? Are samples on the rising or falling edge of clock pulses? These modes are controlled by the third parameter in SPISettings.

The SPI standard is loose and each device implements it a little differently. This means you have to pay special attention to the device's datasheet when writing your code.

Generally speaking, there are four modes of transmission. These modes control whether data is shifted in and out on the rising or falling edge of the data clock signal (called the clock **phase**), and whether the clock is idle when high or low (called the clock **polarity**). The four modes combine polarity and phase according to this table:


| **Mode** | **Clock Polarity (CPOL)** | **Clock Phase (CPHA)** | **Output Edge** | **Data Capture** |
|---|---|---|---|---|
| SPI_MODE0 | 0 | 0 | Falling | Rising |
| SPI_MODE1 | 0 | 1 | Rising | Falling |


Once you have your SPI parameters, use SPI.beginTransaction() to begin using the SPI port. The SPI port will be configured with your all of your settings. The simplest and most efficient way to use SPISettings is directly inside SPI.beginTransaction(). For example:

`SPI.beginTransaction(SPISettings(14000000, MSBFIRST, SPI_MODE0));`

If other libraries use SPI from interrupts, they will be prevented from accessing SPI until you call `SPI.endTransaction()`. The SPI settings are applied at the **begin** of the transaction and `SPI.endTransaction()` **doesn't change** SPI settings. **Unless** you, or some library, **calls** beginTransaction a second time, the setting are **maintained**. You should attempt to minimize the time between before you call `SPI.endTransaction()`, for best compatibility if your program is used together with other libraries which use SPI.

With most SPI devices, after `SPI.beginTransaction()`, you will write the slave select pin LOW, call `SPI.transfer()` any number of times to transfer data, then write the SS pin HIGH, and finally call `SPI.endTransaction()`.

For more on SPI, see [Wikipedia's page on SPI][1] and [Maxembedded SPI][2]

### Connections

The following table display on which pins the SPI lines are broken out on the different Arduino boards:

Note that MISO, MOSI, and SCK are available in a consistent physical location on the ICSP header; this is useful, for example, in designing a shield that works on every board.



### Examples

#### SPI Master 

https://github.com/esp8266/Arduino/tree/master/libraries/SPI

#### SPI Slave

https://github.com/esp8266/Arduino/tree/master/libraries/SPISlave

[1]: http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Mode_Numbers
[2]: http://maxembedded.com/2013/11/serial-peripheral-interface-spi-basics/
